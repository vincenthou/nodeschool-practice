# 安装

```sh
npm install -g functional-javascript-workshop
```

# 心得

* 函数式编程描述的是输入和输出的映射关系，函数实现了从输入到输出的转化
* 在JS中数组上提供了很多声明式的方式来对集合中的元素操作，这些方法屏蔽了迭代的细节，使用方法名表示输入数组和输出数组的映射关系，通过回调方法的方式对迭代中单个元素应用实现由输入到输出的转化，由于这些方法的输入和输出都是数组，从而可以使用链式调用的形式组合成一个更复杂的映射关系
* 递归一般的写法：1. 指定递归的退出条件; 2. 处理递归当前部分; 3. 描述递归剩余部分通过调用自身的s方式
* 由于递归处理会在满足退出条件的时候才会开始返回数据，也就是调用栈之前一直在push，只有最后才开始pop，如果调用的堆栈太深会早上溢出。在nodejs中有两种处理方式，一种是通过使用setTimeout将一部分（或者全部）产生堆栈堆积的函数调用放到队列里面，交由事件循环处理（保证堆积调用栈不会太高），另一种方式是使用函数作为返回值，在函数调用产生堆栈的时候快速返回，不会造成堆积，参考 `trampoline` 的实现
* 在递归调用中可以通过传递引用参数实现递归调用的全局数据共享
* 所谓偏函数或者说部分应用函数，一般会返回一个新函数，这个新函数会使用原函数在被调用的时候传入的参数，由于在一个新的函数作用域被引用，原函数参数的声明周期被延长，实现了缓存的效果。也可以在原函数的作用域中定义一些自定义的变量，在后续新函数的调用中可以共享的数据
* 通过 `bind` 方法可以绑定函数调用的context和默认的调用参数，相当于省掉了 **写包装函数，然后在函数内拼绑定的原函数和新函数参数拼接后通过 `apply` 调用** （比较 `logger` 和 `logger-bind`）, 在创建偏函数的时候非常方便，使用递归可以很容易实现 `n` 级颗粒化的效果，参考 `curry-n` 的实现
* 使用 `call` 和 `apply` 可以让对象调用原型链上不存在的方法，所以可以实现直接对 array-like 的对象调用数组操作的方法（前提是这个不存在的方法是可以处理这个对象的）